# -*- coding: utf-8 -*-
"""traction_large_cyclique_rebouah.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a0rFThpTnuSuM8pItWBElTJYO9v1qKtT

Import des bibliothèques
"""
import time
import numpy as np
import pandas as pd
from scipy.signal import lfilter, savgol_filter
import matplotlib.pyplot as plt
from indentation.experiments.zwick.post_processing.read_file import Files_Zwick
import indentation.caracterization.large_tension.post_processing.utils as large_tension_utils
from indentation.caracterization.large_tension.figures.utils import CreateFigure, Fonts, SaveFigure
from scipy import integrate
from matplotlib.widgets import Slider, Button

"""Récupération des données expérimentales"""





def read_sheet_in_datafile(datafile, sheet):
    """
    Extracts the measured time, force and displacement values in a sheet

    Parameters:
        ----------
        datafile: string
            name of the datafile to be read
        sheet: string
            name of the sheet to be read

    Returns:
        -------
        time: pandasArray
            list of the time values (in seconds) in the sheet of the datafile
        force: pandasArray
            list of the force values (in Newtons) in the sheet of the datafile
        disp: pandasArray
            list of the displacement values (in mm) in the sheet of the datafile

    """
    date = datafile[0:6]
    path_to_datafile = large_tension_utils.reach_data_path(date) / datafile
    data_in_sheet = pd.read_excel(path_to_datafile, sheet_name=sheet, header=3, names=["s", "elongation", "MPa-section60mm2", "N", "MPa" ], usecols="A:E", decimal=',')
    time = data_in_sheet.s
    elongation = data_in_sheet.elongation
    stress = data_in_sheet.MPa
    time, elongation, stress = time.to_numpy(), elongation.to_numpy(), stress.to_numpy()
    non_negative_or_null_elongations = np.where(elongation > 0.001)[0]
    rescaled_elongation = np.array([e/100 + 1 for e in elongation[non_negative_or_null_elongations]])
    rescaled_elongation = np.array([e - rescaled_elongation[0] +1 for e in rescaled_elongation])
    stress = savgol_filter(stress, 101, 2)
    rescaled_stress = np.array([s*1000 - stress[0]*1000 for s in stress[non_negative_or_null_elongations]])
    rescaled_time = time[non_negative_or_null_elongations] - time[non_negative_or_null_elongations][0]
    # TODO conclude on the use of  filter or not
    # n=3
    # b= [1.0 / n] * n
    # a=1
    # rescaled_elongation = savgol_filter(rescaled_elongation, 101, n)
    # time = np.array([t - time[1] for t in time])
    return rescaled_time, rescaled_elongation, rescaled_stress

# rescaled_time, rescaled_elongation, rescaled_stress = read_sheet_in_datafile(datafile, sheet)

"""Observation graphique des données expérimentales"""

def plot_data(datafile, sheet):
  rescaled_time, rescaled_elongation, rescaled_stress = read_sheet_in_datafile(datafile, sheet)
  plt.figure()
  plt.plot(rescaled_time, rescaled_stress, '-k', lw=3)
  plt.legend([sheet])
  plt.xlabel('time [s]')
  plt.ylabel('stress [kPa]')
  plt.show()

  plt.figure()
  plt.plot(rescaled_elongation, rescaled_stress, '-k', lw=3)
  plt.legend([sheet])
  plt.xlabel('elongation [-]')
  plt.ylabel('stress [kPa]')
  plt.show()

# plot_data(datafile, sheet)

"""✴ Modélisation ✴

Calcul de la fonction d'évolution du chargement
"""

def compute_f_evol(eta, alpha, I1, I1_max):
  if I1_max - 3 == 0:
    f_evol=1
  else:
    f_evol = 1 - eta* ( ( (I1_max - I1 ) / (I1_max - 3) )**alpha)
  return f_evol

"""Calcul de I1"""

def compute_I1(elongation_x):
    elongation_z = 1/elongation_x
    I1 = 1 + elongation_x**2 + elongation_z**2
    return I1

"""Calcul de la partie visqueuse Q"""
def compute_Q_list(elongation_vec, beta, tau, c1, c2, c3, datafile, sheet):
  time, elongation, _ = read_sheet_in_datafile(datafile, sheet)
  dt_list = np.diff(time)
  # print(len(dt_list))
  Qx_list = np.zeros_like(elongation_vec)
  I1_list = [compute_I1(elongation_x) for elongation_x in elongation_vec]
  S_H_list = [(c1 + 2*c2*(I1_list[i]-3) + 3*c3*(I1_list[i]-3)**2) * elongation_vec[i]**2 for i in range(len(I1_list))]
  for i in range(1, len(Qx_list)):
    # Qz_list[i] = np.exp(-dt_list[i-1]/tau)*Qz_list[i-1] + beta*(S_list[i] - S_list[i-1])
    # Qx_list[i] = tau / (dt_list[0] + tau) * ( beta*(S_H_list[i] - S_H_list[i-1]) + Qx_list[i-1])
    Qx_list[i] = tau / (dt_list[0] + tau) * ( dt_list[0]*beta*S_H_list[i] + Qx_list[i-1])
  return Qx_list

def compute_Q(Q_list, current_elongation, datafile, sheet):
  _, elongation, _ = read_sheet_in_datafile(datafile, sheet)
  # dt_list = np.diff(time)
  # Q_vec = np.zeros_like(elongation)
  # index_time_is_t = np.where(time == current_time)[0][0]
  # s_list = time[:index_time_is_t+1:10]
  def find_Q_at_elongation_s(current_elongation):
    index_elongation_is_current_elongation = np.where(elongation == current_elongation)[0][0]
    # elongation_at_time_s = elongation[index_time_is_s]
    Q_at_elongation_s = Q_list[index_elongation_is_current_elongation]
    return Q_at_elongation_s
  return find_Q_at_elongation_s(current_elongation)
  # integrand_vec=[np.exp((s - current_time)/tau)/(find_elongation_at_time_s(s)**2) for s in s_list]
  # Q = 2 * beta/tau * np.trapz(integrand_vec, s_list)
  # np.exp(-delta_t/tau)*Q_list[i-1] + beta*(S_H_i - S_H_list[i-1])
  # def func_integrand_Q(s, t):
  #   index_time_is_s = np.where(time == s)[0][0]
  #   elongation_at_time_s = elongation[index_time_is_s]
  #   func = np.exp((s - t)/tau)/(elongation_at_time_s**2)
  #   return func
  # y, err = integrate.quad(func, 0, current_time, args=(current_time, tau))
  # Q = 2 * beta/tau * (tau*np.exp(-current_time/tau) +  y)

  # def compute_Q_for_t(t):
  #   Q_previous = tau*np.exp(-t/tau)
  #   Q_current = 0
  #   #test
  #   for i in range(1, len(s_list)):
  #     s = s_list[i]
  #     dt = dt_list[i]
  #     Q_current = Q_previous + dt * func_integrand_Q(s, t)
  #     Q_previous = Q_current
  #     # Q_vec[i] = Q_current
  #   return Q_current
  # Q = compute_Q_for_t(current_time) * 2*beta / tau
  # Q_vec = Q_vec* 2*beta / tau
  # print(Q)
  # return Q
    



"""Calcul de la partie élastique de l'élongation"""

def compute_elongation_x_e_current(elongation_x_e_previous, elongation_x_current, elongation_x_previous, c4, eta_0, dt):
  a = 4*c4/3/eta_0
  b = 0
  c = 1/dt - (elongation_x_current - elongation_x_previous)/elongation_x_current/dt
  d = -4*c4*eta_0/3 - elongation_x_e_previous/dt
  coef = [a, b, c, d]
  roots = np.roots(coef)
  real_root_index = np.where(np.iscomplex(roots)==False)[0]
  real_roots = [np.real(roots[k]) for k in real_root_index]
  real_positive_roots = [r for r in real_roots if r>0.999] #take only real and larger than 1 roots


  try:
    elongation_x_e_current_0 = real_positive_roots[0]
  except:
    elongation_x_e_current_0 = 1
  # print('elongation_e_current', elongation_x_e_current_0)
  # elongation_x_e_current_1 = x1
  # elongation_x_e_current_2 = x2
  # elongation_x_e_current_1 =  (-b - np.sqrt(delta))/(2*a) #elongation has to be larger than 1 ie than 0
  return elongation_x_e_current_0

"""Calcul de la forme analytique de la contrainte"""

# def compute_stress(elongation_x_model, elongation_x_e_model, c1, c2, c3, c4, I1, f_evol):
#   index_elongation_is_elongation_x_model = np.where(elongation == elongation_x_model)[0][0]
#   # elongation_z_model = 1 / elongation_x_model
#   # stress = 2*f_evol * (c1 + 2*c2*(I1-3) + 3*c3*(I1-3)**2) * (elongation_x_model**2 - elongation_z_model**2) + 8*c4 * elongation_x_model * elongation_x_e_model
#   stress = 2*f_evol * (c1 + 2*c2*(I1-3) + 3*c3*(I1-3)**2) * (elongation_x_model**2 - elongation_z_model**2) + 8*c4 * elongation_x_model * elongation_x_e_model
#   return stress

def compute_stress_visc(elongation_x_model, Q_x, c1, c2, c3, I1, f_evol):
  # Q = compute_Q(time[index_elongation_is_elongation_x_model], beta, tau, datafile, sheet)
  elongation_z_model = 1 / elongation_x_model
  # stress = 2*f_evol * (c1 + 2*c2*(I1-3) + 3*c3*(I1-3)**2) * (elongation_x_model**2 - elongation_z_model**2) + 8*c4 * elongation_x_model * elongation_x_e_model
  stress = 2*f_evol * (c1 + 2*c2*(I1-3) + 3*c3*(I1-3)**2) * (elongation_x_model**2 - elongation_z_model**2) + Q_x*(elongation_x_model**2) 
  return stress

"""Calcul de la contrainte analytique pendant l'essai"""

def compute_analytical_stress(datafile, sheet, params):
  # Load experimental data
  time_exp, elongation_exp, stress_exp = read_sheet_in_datafile(datafile, sheet)

  # Initialisation
  # elongation_x_model_list = elongation_exp
  # elongation_x_e_model_list = np.zeros_like(elongation_x_model_list)
  stress_model_list = np.zeros_like(stress_exp)
  time_model_list = time_exp

  I1_model_list = np.zeros_like(elongation_exp)
  I1_model_list[0] = 3
  I1_max = 3

  # elongation_x_model_list[0] = 1
  # elongation_x_e_model_list[0] = 1
  stress_model_list[0] = 0

  # [c1, c2, c3, c4, eta_0, eta, alpha] = params[0]
  [c1, c2, c3, beta, tau, eta, alpha] = params[0]
  Qx_list = compute_Q_list(elongation_exp, beta, tau, c1, c2, c3, datafile, sheet)

  # for i in range(1, len(elongation_x_model_list)):
  for i in range(1, len(elongation_exp)):
    elongation_x_model = elongation_exp[i]
    # elongation_at_time_s = elongation[index_time_is_s]
    Q = Qx_list[i]
    # elongation_x_model = elongation_x_model_list[i]
    I1 = compute_I1(elongation_x_model)
    I1_model_list[i] = I1
    I1_max = np.max(I1_model_list)
    f_evol = compute_f_evol(eta, alpha, I1, I1_max)
    # elongation_x_e_previous = elongation_x_e_model_list[i-1]
    # elongation_x_current = elongation_x_model
    # elongation_x_previous = elongation_x_model_list[i-1]
    # dt = time_intervals_list[i-1]
    # elongation_x_e_current = compute_elongation_x_e_current(elongation_x_e_previous, elongation_x_current, elongation_x_previous, c4, eta_0, dt)

    # elongation_x_e_model_list[i] = elongation_x_e_current
    # stress = compute_stress(elongation_x_model, elongation_x_e_current, c1, c2, c3, c4, I1, f_evol)
    stress = compute_stress_visc(elongation_x_model, Q, c1, c2, c3, I1, f_evol)
    stress_model_list[i] = stress
  return stress_model_list



"""Comparaison modèle-exp avec une figure adaptative"""

from typing_extensions import ParamSpec
def make_adaptive_plot_stress_vs_time(datafile, sheet):
  time_exp, elongation_exp, stress_exp = read_sheet_in_datafile(datafile, sheet)
  # c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init = 4, 6.2, 0.3, 0.07, 1,  1, 0.5
  c1_init, c2_init, c3_init, beta_init, tau_init, eta_init, alpha_init = 4, 6.2, 0.3, 0.07, 1,  1, 0.5

  fig, ax = plt.subplots()
  line, = ax.plot(time_exp, compute_analytical_stress(datafile, sheet, [[c1_init, c2_init, c3_init, beta_init, tau_init, eta_init, alpha_init]]), '-b', lw=2)
  # line, = ax.plot(time_exp, compute_analytical_stress(datafile, sheet, [[c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init]]), '-b', lw=2)
  # line, = ax.plot(time_exp, compute_analytical_stress(datafile, sheet, [[c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init]]), '-b', lw=2)
  # adjust the main plot to make room for the sliders
  fig.subplots_adjust(left=0.4, bottom=0.25)
  ax.plot(time_exp, stress_exp, ':k', alpha=0.8)
  ax.set_xlabel('time [s]')
  ax.set_ylabel('Pi stress [kPa]')
  ax.set_ylim((0, 100))


  # Make a horizontal slider to control c1.
  axc1 = fig.add_axes([0.25, 0.1, 0.65, 0.03])
  c1_slider = Slider(
      ax=axc1,
      label='c1',
      valmin=0,
      valmax=20,
      valinit=c1_init,
      color='y'
  )

  # Make a vertically oriented slider to control c2
  axc2 = fig.add_axes([0.1, 0.25, 0.0225, 0.63])
  c2_slider = Slider(
      ax=axc2,
      label="c2",
      valmin=0,
      valmax=20,
      valinit=c2_init,
      orientation="vertical",
      color='m'
  )

  # Make a vertically oriented slider to control c3
  axc3 = fig.add_axes([0.175, 0.25, 0.0225, 0.63])
  c3_slider = Slider(
      ax=axc3,
      label="c3",
      valmin=0,
      valmax=20,
      valinit=c3_init,
      orientation="vertical",
      color='r'
  )

  # # Make a vertically oriented slider to control c4
  # axc4 = fig.add_axes([0.25, 0.25, 0.0225, 0.63])
  # c4_slider = Slider(
  #     ax=axc4,
  #     label="c4",
  #     valmin=-10,
  #     valmax=10,
  #     valinit=c4_init,
  #     orientation="vertical",
  #     color='g'
  # )
  # Make a vertically oriented slider to control beta
  axbeta = fig.add_axes([0.25, 0.25, 0.0225, 0.63])
  beta_slider = Slider(
      ax=axbeta,
      label="beta",
      valmin=0.1,
      valmax=10,
      valinit=beta_init,
      orientation="vertical",
      color='g'
  )

  # # Make a vertically oriented slider to control c4
  # axeta_0 = fig.add_axes([0.275, 0.25, 0.0225, 0.63])
  # eta_0_slider = Slider(
  #     ax=axeta_0,
  #     label="eta_0",
  #     valmin=-10,
  #     valmax=10,
  #     valinit=eta_0_init,
  #     orientation="vertical",
  #     color='g'
  # )
  # Make a vertically oriented slider to control tau
  axtau = fig.add_axes([0.275, 0.25, 0.0225, 0.63])
  tau_slider = Slider(
      ax=axtau,
      label="tau",
      valmin=0.1,
      valmax=20,
      valinit=tau_init,
      orientation="vertical",
      color='g'
  )
  
  # Make a vertically oriented slider to control eta
  axeta = fig.add_axes([0.325, 0.25, 0.0225, 0.63])
  eta_slider = Slider(
      ax=axeta,
      label=r"$\eta$",
      valmin=1,
      valmax=20,
      valinit=eta_init,
      orientation="vertical",
      color='b'
  )

  # Make a vertically oriented slider to control alpha
  axalpha = fig.add_axes([0.4, 0.25, 0.0225, 0.63])
  alpha_slider = Slider(
      ax=axalpha,
      label=r"$\alpha$",
      valmin=0.1,
      valmax=5,
      valinit=alpha_init,
      orientation="vertical",
      color='r'
  )


  def compute_adaptive_stress(c1, c2, c3, beta, tau, eta, alpha):
  # def compute_adaptive_stress(c1, c2, c3, c4, eta_0, eta, alpha):
    # params = [[c1, c2, c3, c4, eta_0, eta, alpha]]
    params = [[c1, c2, c3, beta, tau, eta, alpha]]
    stress_list = compute_analytical_stress(datafile, sheet, params)
    return stress_list

  # The function to be called anytime a slider's value changes
  def update(val):
      # line.set_ydata(compute_adaptive_stress(c1_slider.val, c2_slider.val, c3_slider.val, c4_slider.val, eta_0_slider.val, eta_slider.val, alpha_slider.val))
      line.set_ydata(compute_adaptive_stress(c1_slider.val, c2_slider.val, c3_slider.val, beta_slider.val, tau_slider.val, eta_slider.val, alpha_slider.val))
      fig.canvas.draw_idle()

  # register the update function with each slider
  c1_slider.on_changed(update)
  c2_slider.on_changed(update)
  c3_slider.on_changed(update)
  # c4_slider.on_changed(update)
  beta_slider.on_changed(update)
  # eta_0_slider.on_changed(update)
  tau_slider.on_changed(update)
  eta_slider.on_changed(update)
  alpha_slider.on_changed(update)


  # Create a `matplotlib.widgets.Button` to reset the sliders to initial values.
  resetax = fig.add_axes([0.8, 0.025, 0.1, 0.04])
  button = Button(resetax, 'Reset', hovercolor='0.975')

  def reset(event):
    c1_slider.reset()
    c2_slider.reset()
    c3_slider.reset()
    # c4_slider.reset()
    beta_slider.reset()
    eta_slider.reset()
    # eta_0_slider.reset()
    tau_slider.reset()
    alpha_slider.reset()
  button.on_clicked(reset)

  plt.show()

def make_adaptive_plot_stress_vs_elongation(datafile, sheet):
  time_exp, elongation_exp, stress_exp = read_sheet_in_datafile(datafile, sheet)
  c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init = 4, 6.2, 0.3, 0.07, 1,  1, 0.5
  fig, ax = plt.subplots()
  line, = ax.plot(elongation_exp, compute_analytical_stress(datafile, sheet, [[c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init]]), '-b', lw=2)
  # line, = ax.plot(elongation_exp, compute_analytical_stress(datafile, sheet, [[c1_init, c2_init, c3_init, c4_init, eta_0_init, eta_init, alpha_init]]), '-b', lw=2)
  # adjust the main plot to make room for the sliders
  fig.subplots_adjust(left=0.4, bottom=0.25)
  ax.plot(elongation_exp, stress_exp, ':k', alpha=0.8)
  ax.set_xlabel('elongation [-]')
  ax.set_ylabel('Pi stress [kPa]')
  ax.set_ylim((0, 100))


  # Make a horizontal slider to control c1.
  axc1 = fig.add_axes([0.25, 0.1, 0.65, 0.03])
  c1_slider = Slider(
      ax=axc1,
      label='c1',
      valmin=0,
      valmax=20,
      valinit=c1_init,
      color='y'
  )

  # Make a vertically oriented slider to control c2
  axc2 = fig.add_axes([0.1, 0.25, 0.0225, 0.63])
  c2_slider = Slider(
      ax=axc2,
      label="c2",
      valmin=0,
      valmax=20,
      valinit=c2_init,
      orientation="vertical",
      color='m'
  )

  # Make a vertically oriented slider to control c3
  axc3 = fig.add_axes([0.175, 0.25, 0.0225, 0.63])
  c3_slider = Slider(
      ax=axc3,
      label="c3",
      valmin=0,
      valmax=20,
      valinit=c3_init,
      orientation="vertical",
      color='r'
  )

  # Make a vertically oriented slider to control c4
  axc4 = fig.add_axes([0.25, 0.25, 0.0225, 0.63])
  c4_slider = Slider(
      ax=axc4,
      label="c4",
      valmin=-10,
      valmax=10,
      valinit=c4_init,
      orientation="vertical",
      color='g'
  )

  # Make a vertically oriented slider to control c4
  axeta_0 = fig.add_axes([0.275, 0.25, 0.0225, 0.63])
  eta_0_slider = Slider(
      ax=axeta_0,
      label="eta_0",
      valmin=-10,
      valmax=10,
      valinit=eta_0_init,
      orientation="vertical",
      color='g'
  )
  # Make a vertically oriented slider to control eta
  axeta = fig.add_axes([0.325, 0.25, 0.0225, 0.63])
  eta_slider = Slider(
      ax=axeta,
      label=r"$\eta$",
      valmin=1,
      valmax=20,
      valinit=eta_init,
      orientation="vertical",
      color='b'
  )

  # Make a vertically oriented slider to control alpha
  axalpha = fig.add_axes([0.4, 0.25, 0.0225, 0.63])
  alpha_slider = Slider(
      ax=axalpha,
      label=r"$\alpha$",
      valmin=0.1,
      valmax=5,
      valinit=alpha_init,
      orientation="vertical",
      color='r'
  )


  def compute_adaptive_stress(c1, c2, c3, c4, eta_0, eta, alpha):
    params = [[c1, c2, c3, c4, eta_0, eta, alpha]]
    stress_list = compute_analytical_stress(datafile, sheet, params)
    return stress_list

  # The function to be called anytime a slider's value changes
  def update(val):
      line.set_ydata(compute_adaptive_stress(c1_slider.val, c2_slider.val, c3_slider.val, c4_slider.val, eta_0_slider.val, eta_slider.val, alpha_slider.val))
      fig.canvas.draw_idle()

  # register the update function with each slider
  c1_slider.on_changed(update)
  c2_slider.on_changed(update)
  c3_slider.on_changed(update)
  c4_slider.on_changed(update)
  eta_0_slider.on_changed(update)
  eta_slider.on_changed(update)
  alpha_slider.on_changed(update)


  # Create a `matplotlib.widgets.Button` to reset the sliders to initial values.
  resetax = fig.add_axes([0.8, 0.025, 0.1, 0.04])
  button = Button(resetax, 'Reset', hovercolor='0.975')

  def reset(event):
    c1_slider.reset()
    c2_slider.reset()
    c3_slider.reset()
    c4_slider.reset()
    eta_slider.reset()
    eta_0_slider.reset()
    alpha_slider.reset()
  button.on_clicked(reset)

  plt.show()

""" Comparaison modèle-exp avec un jeu de paramètres fixe"""
def plot_exp_vs_model_params(datafile, sheet, params):
  time, elongation, stress_exp = read_sheet_in_datafile(datafile, sheet)
  stress_model = compute_analytical_stress(datafile, sheet, params)
  
  createfigure = CreateFigure()
  fonts = Fonts()
  savefigure = SaveFigure()
  fig_stress_vs_time = createfigure.rectangle_figure(pixels=180)
  ax_stress_vs_time = fig_stress_vs_time.gca()
  
  fig_stress_vs_elongation = createfigure.rectangle_figure(pixels=180)
  ax_stress_vs_elongation = fig_stress_vs_elongation.gca()
  
  ax_stress_vs_time.plot(time, stress_exp, ':k', lw=3, label='exp')
  ax_stress_vs_time.plot(time, stress_model, '-r', lw=3, label='num')
  ax_stress_vs_time.set_title(sheet, font=fonts.serif(), fontsize=26)
  ax_stress_vs_time.set_xlabel('time [s]', font=fonts.serif(), fontsize=26)
  ax_stress_vs_time.set_ylabel('stress [kPa]', font=fonts.serif(), fontsize=26)
  ax_stress_vs_time.legend(prop=fonts.serif(), loc='upper left', framealpha=0.7)

  ax_stress_vs_elongation.plot(elongation, stress_exp, ':k', lw=3, label='exp')
  ax_stress_vs_elongation.plot(elongation, stress_model, '-r', lw=3, label='num')
  ax_stress_vs_elongation.set_title(sheet, font=fonts.serif(), fontsize=26)
  ax_stress_vs_elongation.set_xlabel('elongation [-]', font=fonts.serif(), fontsize=26)
  ax_stress_vs_elongation.set_ylabel('stress [kPa]', font=fonts.serif(), fontsize=26)
  ax_stress_vs_elongation.legend(prop=fonts.serif(), loc='upper left', framealpha=0.7)

  savefigure.save_as_png(fig_stress_vs_time, datafile[0:6] + "stress_time_exp_numRebouah_" + sheet + "_test")
  savefigure.save_as_png(fig_stress_vs_elongation, datafile[0:6] + "stress_elongation_exp_numRebouah_" + sheet + "_test")

  plt.close(fig_stress_vs_elongation)
  plt.close(fig_stress_vs_time)


"""Find optimal parameters"""

from sklearn.metrics import mean_squared_error
from scipy.optimize import curve_fit, minimize, rosen, rosen_der


def find_optimal_parameters(datafile, sheet, minimization_method):
  time_exp, elongation_exp, stress_exp = read_sheet_in_datafile(datafile, sheet)
  c1_init, c2_init, c3_init, beta_init, tau_init, eta_init, alpha_init = 10, 5, 0.5, 0.07, 1,  1, 0.5
  initial_guess_values = [c1_init, c2_init, c3_init, beta_init, tau_init, eta_init, alpha_init]
  bounds_values = [(0.1, 30), (0.1, 30), (0.1, 10), (0.01, 50), (1, 100), (1, 5), (0.1, 5)]
  # beta eta and alpha have to be positive
  def minimization_function(params):
      stress_list_model = compute_analytical_stress(datafile, sheet, [params])
      n = len(stress_list_model)
      stress_list_exp = stress_exp
      least_square = mean_squared_error(stress_list_exp[0:int(n/2)], stress_list_model[0:int(n/2)])
      return least_square

  res = minimize(minimization_function, initial_guess_values, method=minimization_method, bounds=bounds_values,
            options={'disp': False})
  params_opti = res.x
  return params_opti

"""Compare optimized to experimental stress"""

def plot_comparison_stress_model_experiment(datafile, sheet, minimization_method, suffix):
  createfigure = CreateFigure()
  fonts = Fonts()
  savefigure = SaveFigure()
  time_exp, elongation_exp, stress_exp = read_sheet_in_datafile(datafile, sheet)
  params_opti = find_optimal_parameters(datafile, sheet, minimization_method)
  stress_list_model = compute_analytical_stress(datafile, sheet, [params_opti])
  n = len(stress_list_model)
  fig_stress_vs_elongation = createfigure.rectangle_figure(pixels=180)
  ax_stress_vs_elongation = fig_stress_vs_elongation.gca()
  ax_stress_vs_elongation.plot(elongation_exp[0:int(n/2)], stress_exp[0:int(n/2)], '-k', lw=1, label='exp')
  ax_stress_vs_elongation.plot(elongation_exp[0:int(n/2)], stress_list_model[0:int(n/2)], '-r', lw=1, label='model')
  ax_stress_vs_elongation.set_xlabel(r"$\lambda_x$ [-]", font=fonts.serif(), fontsize=26)
  ax_stress_vs_elongation.set_ylabel(r"$\sigma_x^{exp}$ [kPa]", font=fonts.serif(), fontsize=26)
  ax_stress_vs_elongation.legend(prop=fonts.serif(), loc='upper left', framealpha=0.7)
  savefigure.save_as_png(fig_stress_vs_elongation, datafile[0:6] + "stress_elong_exp_numRebouah_" + sheet + "_" + minimization_method + "_" + suffix)
  
  fig_stress_vs_time = createfigure.rectangle_figure(pixels=180)
  ax_stress_vs_time = fig_stress_vs_time.gca()
  ax_stress_vs_time.plot(time_exp[0:int(n/2)], stress_exp[0:int(n/2)], '-k', lw=1, label='exp')
  ax_stress_vs_time.plot(time_exp[0:int(n/2)], stress_list_model[0:int(n/2)], '-r', lw=1, label='model')
  ax_stress_vs_time.set_xlabel("time [s]", font=fonts.serif(), fontsize=26)
  ax_stress_vs_time.set_ylabel(r"$\sigma_x^{exp}$ [kPa]", font=fonts.serif(), fontsize=26)
  ax_stress_vs_time.legend(prop=fonts.serif(), loc='upper left', framealpha=0.7)
  savefigure.save_as_png(fig_stress_vs_time, datafile[0:6] + "stress_time_exp_numRebouah_" + sheet + "_" + minimization_method+ "_" + suffix)

  plt.close(fig_stress_vs_elongation)
  plt.close(fig_stress_vs_time)
  
  
if __name__ == "__main__":
  sheet = "C1SA"
  datafile = "231012_large_tension_data.xlsx"
  files_zwick = Files_Zwick('large_tension_data.xlsx')

  c1_test, c2_test, c3_test, beta_test, tau_test, eta_test, alpha_test = 4, 6.2, 0.3, 0.07, 1,  1, 0.5
  params_test = [[c1_test, c2_test, c3_test, beta_test, tau_test, eta_test, alpha_test]]
  start_time = time.time()
  datafile_as_pds, sheets_list_with_data = files_zwick.get_sheets_from_datafile(datafile)
  # plot_exp_vs_model_params(datafile, sheet, params_test)
  # make_adaptive_plot_stress_vs_elongation(datafile, "C2TA")
  # make_adaptive_plot_stress_vs_time(datafile, "C2TA")
  minimization_method_list = ['Powell']# ['Nelder-Mead', 'Powell', 'CG', 'BFGS', 'L-BFGS-B', 'TNC', 'COBYLA', 'SLSQP', 'trust-constr', 'dogleg', 'trust-ncg', 'trust-exact', 'trust-krylov']
  suffix = "0-300_Sh"
  for minimization_method in minimization_method_list:
    for sheet in sheets_list_with_data:
      try:
        print('started', minimization_method)
        plot_comparison_stress_model_experiment(datafile, sheet, minimization_method, suffix)
        print('done succeed', minimization_method)
        print("--- %s seconds ---" % (time.time() - start_time))
      except:
        print('failed', minimization_method)
  #   #   None
      



